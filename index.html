<!DOCTYPE html> 
<html lang="en"> 
	<head> 
		<script src="main.js"></script> 
		<link rel="stylesheet" href="style.css" /> 
		<meta charset="UTF-8" /> 
		<meta name="viewport"
			content="width=device-width, initial-scale=1.0" /> 
		<title>Document</title> 
	</head> 
	<body> 
		<!-- Here a loader is created which 
			loads till response comes -->
		<div class="d-flex justify-content-center"> 
			<div class="spinner-border"
				role="status" id="loading"> 
				<span class="sr-only">Loading...</span> 
			</div> 
		</div> 
		<!-- table for showing data -->
		<div id="fetchedData"></div> 
    <div id="wordMapData"></div> 
	</body> 
</html> 
<script>
'use strict';
// Function to hide the loader 
function hideloader() { 
	document.getElementById('loading').style.display = 'none'; 
} 
// Function to define innerHTML for HTML table 
function show(data) {  
	// Setting innerHTML as tab variable 
	document.getElementById("fetchedData").innerHTML = data; 
}
(async () => {
// Step 1: start the fetch and obtain a reader
let response = await fetch('https://norvig.com/big.txt');

const reader = response.body.getReader();

// Step 2: get total length
const contentLength = +response.headers.get('Content-Length');

// Step 3: read the data
let receivedLength = 0; // received that many bytes at the moment
let chunks = []; // array of received binary chunks (comprises the body)
while(true) {
  const {done, value} = await reader.read();

  if (done) {
    break;
  }

  chunks.push(value);
  receivedLength += value.length;

  console.log(`Received ${receivedLength} of ${contentLength}`)
}

// Step 4: concatenate chunks into single Uint8Array
let chunksAll = new Uint8Array(receivedLength); // (4.1)
let position = 0;
for(let chunk of chunks) {
  chunksAll.set(chunk, position); // (4.2)
  position += chunk.length;
}

// Step 5: decode into a string
let result = new TextDecoder("utf-8").decode(chunksAll);
//console.log(result);
// We're done!
if (result) { 
		hideloader(); 
	} 
  show(result);

function createWordMap (wordsArray) {

  // create map for word counts
  var wordsMap = {};
  /*
    wordsMap = {
      'Oh': 2,
      'Feelin': 1,
      ...
    }
  */
  wordsArray.forEach(function (key) {
    if (wordsMap.hasOwnProperty(key)) {
      wordsMap[key]++;
    } else {
      wordsMap[key] = 1;
    }
  });

  return wordsMap;

};
console.log(result.replace(/[^a-zA-Z ]/g, "").split(" ").filter(function(i){return i!=""}))
//var wordsArray = splitByWords(result);
//console.log(wordsArray)
console.time('map');

  var wordsMap = createWordMap(result.replace(/[^a-zA-Z ]/g, "").split(" ").filter(function(i){return i!=""}));
  console.log(wordsMap);
  document.getElementById("wordMapData").innerHTML = JSON.stringify(wordsMap);
  // Create items array
var items = Object.keys(wordsMap).map(function(key) {
  return [key, wordsMap[key]];
});

// Sort the array based on the second element
items.sort(function(first, second) {
  return second[1] - first[1];
});

// Create a new array with only the first 5 items
console.log(items.slice(0, 10));
var urls=['https://dictionary.yandex.net/api/v1/dicservice.json/lookup?key=dict.1.1.20170610T055246Z.0f11bdc42e7b693a.eefbde961e10106a4efa7d852287caa49ecc68cf&lang=en-en&text=with','https://dictionary.yandex.net/api/v1/dicservice.json/lookup?key=dict.1.1.20170610T055246Z.0f11bdc42e7b693a.eefbde961e10106a4efa7d852287caa49ecc68cf&lang=en-en&text=this']
Promise.all(urls.map(u=>fetch(u))).then(responses =>
    Promise.all(responses.map(res => res.json()))
).then(texts => {
console.log(texts)
});
  console.timeLog('map');
  })()
</script>
